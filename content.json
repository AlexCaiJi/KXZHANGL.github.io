{"pages":[{"title":"","text":"nWzxsyn5Oi","link":"/baidu_verify_nWzxsyn5Oi.html"},{"title":"","text":"google-site-verification: googlef4c2c5b179b58e86.html","link":"/googlef4c2c5b179b58e86.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/19/hello-world/"},{"title":"JSPatch 热更新","text":"JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C/Swift 原生接口。 获得脚本语言的优势,为项目动态添加模块，或替换项目原生代码动态修复 bug,听起来是不是很秀,但是过不了审核!过不审核不要紧,重在探索嘛,其实我是在企业包加入的JSPatch JSPatch官网:http://www.jspatch.com 1.注册JSPatch账号,创建应用,获取AppKey和私钥 2.生成 RSA 密钥在 Mac 终端上执行 openssl，再执行以下三句命令，生成 PKCS8 格式的 RSA 公私钥，执行过程中提示输入密码，密码为空（直接回车）就行。1234openssl &gt;genrsa -out rsa_private_key.pem 1024pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocryptrsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 这样在执行的目录下就有了 rsa_private_key.pem 和 rsa_public_key.pem 这两个文件。这里生成了长度为 1024 的私钥，长度可选 1024 / 2048 / 3072 / 4096 …。 3.生成公钥可以通过 RSA配置自动生成 工具生成配置代码，打开 rsa_public_key.pem，复制内容到框里点击 生成配置代码 就可以了 4.工程配置代码,OC代码通过桥接文件在Swift中调用把SDK下载下来,拖入工程,或者cocoapods集成12pod &apos;JSPatchPlatformx&apos; pod &apos;JSPatch&apos; 123456789101112131415/** JSPatch appKey */static NSString *const kJSPatchKey = @&quot;jsPatch官网申请的AppKey&quot;;static NSString *const kJSPatchPublicKey = @&quot;-----BEGIN PUBLIC KEY-----\\n 生成的公钥 \\n-----END PUBLIC&quot;[JSPatch startWithAppKey:kJSPatchKey];[JSPatch setupRSAPublicKey:kJSPatchPublicKey];[JSPatch setupCallback:^(JPCallbackType type, NSDictionary *data, NSError *error {NSLog(data,error); }];[JSPatch showLog];#ifdef DEBUG[JSPatch setupDevelopment];#endif[JSPatch sync];[JSPatch testScriptInBundle]; /// 测试本地js补丁方法 如果打开此方法-以上方法需要全部屏蔽 Swift中使用注意事项: 所有自定义的属性和方法前面要加 @objc dynamic关键字,使其拥有runtime属性,才可以动态去修改,可以参考作者此文 [https://www.cnblogs.com/canghaixiaoyuer/p/5367760.html] 并且一定要继承NSObject的类才支持修改,例如继承Array就不支持修改 补丁的版本号一定要和工程版本号同步 注意在 JSPatch 平台的规范里，JS脚本的文件名必须是 main.js 使用 defineClass() 覆盖 Swift 类时，类名应为 项目名.原类名，例如项目 demo 里用 Swift 定义了 ViewController 类，在 JS 覆盖这个类方法时要这样写：defineClass(‘demo.ViewController’, {}) 对于调用已在 swift 定义好的类，也是一样：require(‘demo.ViewController’) 5.配置补丁JS文件如下:123456789101112131415161718defineClass(&apos;JSPatchSwift.KXCrashTableVC&apos;, {viewDidLoad: function() {console.log(&apos;js viewDidLoad begin&apos;)self.ORIGviewDidLoad()console.log(&apos;js viewDidLoad end&apos;)},testLog: function() {console.log(&apos;js ViewController testlog&apos;)},tableView_cellForRowAtIndexPath: function(tableView, indexPath) {console.log(&apos;tableView_cellForRowAtIndexPath testlog&apos;)var cell = tableView.dequeueReusableCellWithIdentifier(&quot;reuseIdentifier&quot;)cell.textLabel().setText(self.dataArray().toJS()[indexPath.row()])return cell} }) 通过[JSPatch testScriptInBundle]; 方法测试没有问题,补丁上传到JSPatch官网后台即可 补丁只能留存一个版本,不能叠加,当下一个版本发布时尽快用原生代码替换 最后附上代码地址:https://github.com/KXZHANGL/KXJSPatchSwift","link":"/2019/03/26/JSPatch-热更新/"},{"title":"第三方布局框架Neon初探","text":"github地址：https://github.com/mamaral/Neon 居中设置 view 在 superview 的中心，调用 anchorInCenter()并设置view大小,相当于frame center12view1.anchorInCenter(width: 300, height: 300)imgV.anchorInCenter(width: 150, height: 150) 填充如果想 view 填充superview，设置距离superview的边框距离, 调用 fillSuperview()12imgV.fillSuperview()imgV.fillSuperview(left: 20, right: 5, top: 30, bottom: 5) 角对齐view 相对于 superview 固定于某个角，调用anchorInCorner(),并传入要对齐哪个角的参数1234view1.anchorInCorner(.topLeft, xPad: 20, yPad: 100, width: 100, height: 100)view2.anchorInCorner(.topRight, xPad: 20, yPad: 50, width: 100, height: 100)view3.anchorInCorner(.bottomLeft, xPad: 20, yPad: 20, width: 100, height: 100)view4.anchorInCorner(.bottomRight, xPad: 20, yPad: 30, width: 100, height: 100) 边对齐如果想让 view 相对于 superview 的某一边依靠对齐，调用anchorToEdge,自动居中对齐1234view1.anchorToEdge(.top, padding: 300, width: 100, height: 100)view2.anchorToEdge(.left, padding: 0, width: 100, height: 100)view3.anchorToEdge(.bottom, padding: 88, width: 100, height: 100)view4.anchorToEdge(.right, padding: 0, width: 100, height: 100) 边填充如果想让 view 相对于 superview 的某一边居中对齐并自动填拉伸充，调用anchorAndFillEdge()1234view1.anchorAndFillEdge(.top, xPad: size + 5, yPad: 88, otherSize: size)view2.anchorAndFillEdge(.bottom, xPad: size + 5, yPad: 83, otherSize: size)view3.anchorAndFillEdge(.left, xPad: 0, yPad: 0, otherSize: size)view4.anchorAndFillEdge(.right, xPad: 0, yPad: 0, otherSize: size) 相对对齐距离相对view右边 居 上-中-下1234view1.anchorInCenter(width: 200, height: 200)view2.align(.toTheRightMatchingTop, relativeTo: view1, padding: 5, width: 50, height: 50)view3.align(.toTheRightMatchingBottom, relativeTo: view1, padding: 5, width: 50, height: 50)view4.align(.toTheRightCentered, relativeTo: view1, padding: 5, width: 50, height: 50) 距离相对view左边 居 上 中 下123view2.align(.toTheLeftMatchingTop, relativeTo: view1, padding: 5, width: 50, height: 50)view3.align(.toTheLeftMatchingBottom, relativeTo: view1, padding: 5, width: 50, height: 50)view4.align(.toTheLeftCentered, relativeTo: view1, padding: 5, width: 50, height: 50) 距离相对view下边 居 上 中 下123view2.align(.underMatchingLeft, relativeTo: view1, padding: 5, width: 50, height: 50)view3.align(.underMatchingRight, relativeTo: view1, padding: 5, width: 50, height: 50)view4.align(.underCentered, relativeTo: view1, padding: 5, width: 50, height: 50) 距离相对view上边 居 上 中 下123view2.align(.aboveMatchingLeft, relativeTo: view1, padding: 5, width: 50, height: 50)view3.align(.aboveMatchingRight, relativeTo: view1, padding: 5, width: 50, height: 50)view4.align(.aboveCentered, relativeTo: view1, padding: 5, width: 50, height: 50) 对齐并填充不知道或者没法指定一个相对视图的大小，但又要兼顾填充和对齐，并且还依赖与相邻的 view。调用alignAndFill()、alignAndFillWidth()、alignAndFillHeight()1234view1.anchorInCenter(width: 200, height: 200)view2.alignAndFillWidth(align: .toTheRightMatchingTop, relativeTo: view1, padding: 5, height: 30)view3.alignAndFillHeight(align: .aboveCentered, relativeTo: view1, padding: 50, width: 60)view4.alignAndFill(align: .toTheLeftMatchingTop, relativeTo: view1, padding: 5) 挤压对齐如果两个 view 夹着中间一个 view 的需求，调用alignBetweenHorizontal()和alignBetweenVertical() 12345view1.anchorInCenter(width: 150, height: 300)view2.align(.toTheRightMatchingTop, relativeTo: view1, padding: 5, width: 100, height: 100)view3.align(.toTheRightMatchingBottom, relativeTo: view1, padding: 5, width: 100, height: 100)view4.align(.toTheRightCentered, relativeTo: view1, padding: 5, width: 100, height: 100)view4.alignBetweenVertical(align: .aboveMatchingRight, primaryView: view3, secondaryView: view2, padding: 10, width: 50) 组合多个view一起组合布局,调用groupInCenter()、groupInCorner()、groupAgainstEdge() 居中对齐组合12view.groupInCenter(group: .vertical, views: [view1,view2,view3], padding: 10, width: size, height: size)view.groupInCenter(group: .horizontal, views: [view1,view2,view3], padding: 20, width: size, height: size) 角对齐组合 相对于superview某一个角组合排布12view.groupInCorner(group: .horizontal, views: [view1, view2, view3], inCorner: .bottomLeft, padding: 10, width: size, height: size)view.groupInCorner(group: .vertical, views: [view1, view2, view3], inCorner: .bottomRight, padding: 10, width: size, height: size) 边对齐组合,相对于superview某一条边的中点排布12view.groupAgainstEdge(group: .horizontal, views: [view1, view2, view3], againstEdge: .left, padding: 10, width: size, height: size)view.groupAgainstEdge(group: .vertical, views: [view1, view2, view3], againstEdge: .bottom, padding: 10, width: size, height: size) 最后,我想说","link":"/2019/03/19/第三方布局框架Neon初探/"}],"tags":[{"name":"swift4.0","slug":"swift4-0","link":"/tags/swift4-0/"},{"name":"热更新","slug":"热更新","link":"/tags/热更新/"},{"name":"JSPatch","slug":"JSPatch","link":"/tags/JSPatch/"}],"categories":[{"name":"第三方库","slug":"第三方库","link":"/categories/第三方库/"}]}